// Generated by CoffeeScript 1.3.3
(function() {

  $.fn.clipthru = function(options) {
    var addIdToBlocks, allBlocks, allClones, attachListeners, clipOverlayClone, clipOverlayOriginal, collidingBlocks, collisionTarget, collisionTargetOffset, createOverlayClones, defaults, getAllBlocks, getCollidingBlocks, getCollisionArea, getOverlayOffset, getRelativeCollision, init, overlay, overlayOffset, refresh, settings, updateOverlayClones;
    defaults = {
      method: ['clip', 'clip-path'],
      dataAttribute: 'jq-clipthru',
      simpleMode: false,
      collisionTarget: null,
      blockSource: null,
      angularScope: null,
      angularCompile: null,
      updateOnScroll: true,
      updateOnResize: true,
      updateOnZoom: true,
      autoUpdate: false,
      autoUpdateInterval: 100,
      debug: false
    };
    settings = $.extend(defaults, options);
    overlay = $(this);
    overlayOffset = null;
    if (settings.collisionTarget) {
      collisionTarget = $(overlay.find(settings.collisionTarget).get(0));
    } else {
      collisionTarget = overlay;
    }
    collisionTargetOffset = null;
    allBlocks = null;
    allClones = null;
    collidingBlocks = [];
    getAllBlocks = function() {
      var block, _i, _len, _ref, _results;
      if (settings.blockSource) {
        _ref = settings.blockSource;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          block = _ref[_i];
          if (allBlocks) {
            _results.push(allBlocks = allBlocks.add($(block)));
          } else {
            _results.push(allBlocks = $(block));
          }
        }
        return _results;
      } else {
        return allBlocks = $("[data-" + settings.dataAttribute + "]");
      }
    };
    getOverlayOffset = function() {
      overlayOffset = overlay.get(0).getBoundingClientRect();
      return collisionTargetOffset = collisionTarget.get(0).getBoundingClientRect();
    };
    addIdToBlocks = function() {
      var i;
      i = 0;
      return allBlocks.each(function() {
        $(this).data("" + settings.dataAttribute + "-id", i);
        return i++;
      });
    };
    createOverlayClones = function() {
      return allBlocks.each(function() {
        var clone;
        clone = overlay.clone();
        clone.addClass("" + settings.dataAttribute + "-clone");
        clone.addClass($(this).data(settings.dataAttribute));
        clone.data("" + settings.dataAttribute + "-id", $(this).data("" + settings.dataAttribute + "-id"));
        if (allClones) {
          return allClones = allClones.add(clone);
        } else {
          return allClones = clone;
        }
      });
    };
    updateOverlayClones = function() {
      allClones.each(function() {
        var id;
        id = $(this).data("" + settings.dataAttribute + "-id");
        if (collidingBlocks.hasOwnProperty(id)) {
          if (!document.body.contains(this)) {
            $(this).insertAfter(overlay);
            if (settings.angularScope) {
              settings.angularCompile($(this).contents())(settings.angularScope);
            }
          }
          clipOverlayClone(this, getCollisionArea(collidingBlocks[id]));
          if (settings.simpleMode === 'vertical') {
            return clipOverlayOriginal(getRelativeCollision(collidingBlocks[id]));
          }
        } else {
          return $(this).detach();
        }
      });
      if (collidingBlocks.length === 0) {
        return overlay.removeAttr('style');
      }
    };
    getCollisionArea = function(blockOffset) {
      var clipOffset;
      clipOffset = [];
      clipOffset.push(overlayOffset.height - (overlayOffset.bottom - blockOffset.top));
      clipOffset.push(blockOffset.right - overlayOffset.left);
      clipOffset.push(blockOffset.bottom - overlayOffset.top);
      clipOffset.push(overlayOffset.width - (overlayOffset.right - blockOffset.left));
      return clipOffset;
    };
    getRelativeCollision = function(blockOffset) {
      var clipOffset;
      clipOffset = [];
      if (collisionTargetOffset.top <= blockOffset.top) {
        clipOffset.push(0);
        clipOffset.push(blockOffset.top - overlayOffset.top);
      } else if (collisionTargetOffset.bottom >= blockOffset.bottom) {
        clipOffset.push(overlayOffset.height - (overlayOffset.bottom - blockOffset.bottom));
        clipOffset.push(overlayOffset.bottom);
      } else {
        clipOffset = [0, 0];
      }
      return clipOffset;
    };
    getCollidingBlocks = function() {
      collidingBlocks = [];
      return allBlocks.each(function() {
        var blockOffset;
        blockOffset = this.getBoundingClientRect();
        if ((blockOffset.bottom >= collisionTargetOffset.top) && (blockOffset.top <= collisionTargetOffset.bottom) && (blockOffset.left <= collisionTargetOffset.right) && (blockOffset.right >= collisionTargetOffset.left)) {
          return collidingBlocks[$(this).data("" + settings.dataAttribute + "-id")] = blockOffset;
        }
      });
    };
    clipOverlayClone = function(clone, offset) {
      if (settings.simpleMode === 'vertical') {
        return $(clone).css({
          'clip': "rect(" + offset[0] + "px auto " + offset[2] + "px auto)"
        });
      } else {
        return $(clone).css({
          'clip': "rect(" + offset[0] + "px " + offset[1] + "px " + offset[2] + "px " + offset[3] + "px)"
        });
      }
    };
    clipOverlayOriginal = function(offset) {
      return overlay.css({
        'clip': "rect(" + offset[0] + "px auto " + offset[1] + "px auto)"
      });
    };
    refresh = function() {
      getOverlayOffset();
      getCollidingBlocks();
      return updateOverlayClones();
    };
    attachListeners = function() {
      return $(window).on("" + (settings.updateOnResize ? 'resize' : void 0) + " " + (settings.updateOnScroll ? 'scroll' : void 0), function() {
        return refresh();
      });
    };
    init = function() {
      var autoUpdateTimer;
      getAllBlocks();
      if (allBlocks.length > 0) {
        collisionTarget.addClass("" + settings.dataAttribute + "-origin");
        addIdToBlocks();
        createOverlayClones();
        attachListeners();
        refresh();
        clearInterval(typeof autoUpdateTimer !== "undefined" && autoUpdateTimer !== null);
        if (settings.autoUpdate) {
          return autoUpdateTimer = setInterval((function() {
            return refresh();
          }), settings.autoUpdateInterval);
        }
      }
    };
    return init();
  };

}).call(this);
